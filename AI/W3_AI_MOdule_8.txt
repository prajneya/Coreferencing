Welcome friends in the eighth module of a AI. Genetic Algorithms and Travelling salesman problem. Genetic algorithm is little different from conventional AI techniques that is recently added; in fact it is some other researchers do not call it part of AI. I consider it to be part of AI at least the initial part GA was quite associated with AI. I do not want to discuss more about why it is part of AI and why it is not. Let us see why we are discussing about GAs. 

We have seen that AI is about solving difficult problem and GA is one great way of solving difficult problems. In fact, GA has shown that it can actually solve some serious AI problems not sorted for years. So anyway we are not going to discuss much about Mmh what it has done, will, we will see the introduction of GA. 

It is not very similar to something that we have studied so far. It is not about representing a problem in state space, no. It is not about a searching through state space, no. It is not about starting from start state to go to final state, no. It is something different. We do not have heuristic function here. Well, there is something similar available but is not basically heuristic function, something very, very different.

Now what GA is about? GA is about searching solution space. We have already seen that. 

Solution space is – okay – what they won’t search like other search methods that we have seen so far. For example, we have a solution space where we have every node describing a solution. In conventional methods what we do is, you pick up a solution state, look at the heuristic value and then try move to some other solution space with solution state which is better. Or generate from this solution state you generate other solution states and find out which one is better and then you move there, okay like [indiscernible][0:02:19] or something similar. 

In this case, we don’t do it. What we do is something very different. For example, for a given node I have twenty mmh children, I choose of five from it, okay and then I do not do, I do not explore them, what I do I will just mingle them in a way that or – in a way that I generate new nodes out of it. If I have five nodes and for example if you combine one and five and generate a new solution or new two solutions basically think of it, and if you do it that way, out of five you can generate twenty more. Okay.

So again out of that five you pick up first five and so on. So here it is very similar to human being or even living firms. The GA is based on the principle that living – how living firms continue to become better to make sure that they, they adjust with the environment. For example, all the praise the – like deer, what they do? Even while they are, they are grazing they keep on uh, uh hearing the sound and look it around to make sure that there are no carnivorous animals around and if it is so they use their smelling and hearing ability to figure out if they are nearby. And at the first sight of the enemy around they start running. 

Obviously, two abilities deer can save. One, the ability to hear and smell and the other ability is to run fast. And obviously, only those deer who run fast and smell better can survive. Similarly, the carnivorous animals also, okay. They can only survive if they run fast and they are better uh, okay and in making sure that the enemy does not, the [indiscernible][0:04:34] does not get, the, the hint of their moving, so-- that they are on crawl.

Okay, so point is the only better spaces only better individuals are likely to survive. And the second principle of GA is that when better elements that better individuals meet they produce even better offspring. How this is related to GA? It is pretty simple. GA is about representing problems in form of a solution space. So what you do is, you just get five best solutions and then, then mingle them in a way that you get twenty better solutions and then again pick up five, and so and so forth. So this is what GA is all about. Let us begin talking about GA. Let me talk that GA is a huge thing and what I am going to talk about is just I am just going to scratch the surface. We are not going to discuss many things about GA and I have given one or two references at the end of this chapter and end of this module. So if you want, if you are interested in studying more about GA probably those are the references, [Indiscernible][0:05:46] in fact there are many, many more researches on GA.

Okay. Let us begin talking about this thing. As I said the GA is not usual content for AI this thing. There is something called Soft Computing. Now lot of – I do not want to again describe the difference between soft computing and AI because there are lot of people saying one thing, lot of other researchers saying absolutely the other, okay. But many people believe that it is GA is not part of AI, it is part of soft computing. Anyway, let us talk about why it is an excellent method of solving some very, very interesting AI problems. Well, we will actually going to see and find out how useful it is for solving a travelling salesman problem. 

And one great thing about GA is that can handle the combinatorial explosion problem, okay. How it is doing we will see. That is quite different than other algorithms. It is not searching through the search spaces, actually generate solutions, in fact generation of solutions one after the other and doing it in a way that humans and other spaces do in a way that eventually what you get are better solutions search. So after few iterations probably the solutions that you have are better than the earlier ones. Okay. And it is based on the idea of how life forms persist. 

A GA obviously based on one simple principle which Darwin gave long back. survival of the fittest. Obviously, when any spaces have to live and when the condition is that the resources are limited they have to fight for the survival. And all the capability, I talked about deer, even human being. You can see that we have some, we have to have some qualities to survive and though we are better quality we have better chances of survival and it inherits from parents to children, okay so that is something which is very common and seeing across all live firms.

And in – but then inheritance involves lot of randomness. For example, five children of the same parent, same pair of parent are very different from each other. They are quite different from each other. Okay. So that is great things about live firms and the same thing we are going to have adopting GA, that is adopted in GA to solve problems. But then two important principals which I have already talked about let me reiterate them. Better offspring have more chances of survival and then next generation is genetically better. Okay.

What are the functioning of GA? How GA acts, works. In a nutshell, it is defined like this, you have a solution set called SS, if SS is the final solution that it satisfies the criteria that you like to achieve is great. If it is not what you have to do is to select some out of the complete set. To select some you may use a function which is quite similar to heuristic function but here it is called a fitness function, it test whether you are fit. The actual case all spaces, suppose for example you have twenty solutions, what you do is you just let them roam around in the real space, let them vein or survive themselves and those who survive after some time, collect them and make them. What is exactly what happens in—in some cases artificial [Words] [0:09:20] are created where the solutions are send and then will pick up those who survive and so on. But here usually a simpler method is picked up; we apply fitness function and out of twenty select five.

And then again you let them met and generate twenty in the next iteration, I have already talked about, so that is called generate offspring from random current of this thing. Now what you do is, now you have those offspring, the older one are thrown away, okay, so new twenty, now new twenty is pick up five and throw everything. From this five generate twenty, throw this five, out of this twenty again pick up up five throw rest so and so forth. You continue doing that eventually what you get a better solution set hopefully.

Okay, let us jump into little jargon. Okay, the genetic footprint of anybody is called a genome. Genome contains something called chromosomes. The chromosome contains genetic map of individual in form of a DNAs, okay. DNA in turn contains genes, okay which basic building blocks. For example, genes will decide the color of the screen and the type of – color of eyes and so and so forth. Okay, these words we are probably not going to use them anywhere else. Okay. This is the only slide which contains those names, they are all not that important for us as right now, but if you trying to [indiscernible] [0:10:50] deeper into GA later, probably you need to learn more about them. Okay.

For example, one more capability of in gene is to make sure that you—it will have some characteristic for example ability to climb trees and swim and so on. You can see that such characteristics are very, very important for the survival. Okay. And reproduction process helps the genes to carry from parent to offspring, okay. So this process allows those characteristics ability to climb, ability to swim and all that in the offspring. And DNAs are replicated in the offspring. How it is done? And Offspring the child, the children’s genome basically is a combination of parents. 

Now let us learn little more about human genome. The set of genetic information is encoded in human genome. They contain forty six chromosomes and 23 pairs of chromosomes found in the nucleus of each cell, okay, the forty six chromosomes are found. Okay. And the genome in human case is a long stand of estimated thirty five thousand DNAs in humans. Anyway, these are not all are important things, just to make sure you understand what we are talking about. 

Now we are going to talk about GAs in an algorithm, genetic algorithm. What does they do? Okay. They generate solution; they start with a random set, evolve and combine solutions. I have already discussed them. In this case, a chromosome is a string, simple. Okay. Population is a word which used what we have -- I was talking about those twenty then pick up five; so these twenty strings that you pickup in the beginning is called a solution set or it is called population. Okay. And what are the operations that you will have? Simple, you cut some part of the string and paste some part elsewhere and the other one you apply fitness function to the string finding out how good or fit this particular string is. 

There are three basic operations. The first one selects the best members of the population, the member that I was talking about five out of twenty. Recombination, now those five are to be met it together; recombine together to produce next generation that is called recombination. One more important thing here is called Mutation which we are not going to apply in our-- we are not going to discuss further in this module. But mutation is very important. When we are talking about recombination we are talking about combining parents in a way that they inherit almost everything from parent. For example, color of skin and all that are almost similar. The difference is not much. 

But when we talk about mutation is about making sure that there is some real random inheritance takes place. For example, you have a color of skin which is not inherit from either parents Albino for example, or having the heart on the right side or something like that. But sometimes happens due to radiation or some external this thing also input also. But it is basically mutation is never considered good in humans but in here in this case, mutation sometimes is used for-- there is a reason and very similar to something we have seen in this thing, [indiscernible][0:14:122] allow bad move, okay. So mutation is kind of a bad move so you change things in a way when you have two strings, two parents when they met you do not get a string with similar kind of string, you get a string with very, very different characteristic, but in a way we are not going to discuss that in this particular module. 

The first process Selection, in real world as we said, we sent out to survive on their own, those who survive only will met with the others and get better offspring. But that is not happening here. What we do is out of twenty we just apply fitness function like heuristic function, it is like top five or top six or whatever. Okay. The selection process only chooses better candidates based on the fitness value. Okay. The recombination takes random pairs of parent. Now, as I say I have five, so it will pick up one and five or pickup two and three and pick up one and four and so on. It will pick up random parents and generate the thing, it combine them okay. Offspring inherit genes and attributes and this thing the process produces next generation and once you get the new generation the old generation is just wiped off, the new generation takes place, the new generation is going to replace the old generation in this case.

Sometimes obviously the best of the old generation uh, uh strings are cloned into the new one those who have or having better fitness values to make sure that you get a better offspring in the next generation. Again we are not going to do that further here.

I have already told you the mutation is process of adding serious randomness, it is very different when compare it to they see. It changes the properties of the genes on the permanent basis. It is due to gene -- the human and other spices it is basically due to external influences like radiation. In this case, the genes are distorted, okay and the examples are already given, somebody with three eyes, somebody with no hair and so and so forth. A mutation to GA is similar to bad moves in SA, similar to [indiscernible][0:16:36] changes genes drastically but provides an escape route. Sometime you stuck up, okay. You won’t not get further; if there is a mutation probably there is escape route possible. That is why it is allowed in GAs.

Let us pickup something called a Travelling salesman problem. Already talked about that in the first module, let us talk about it again. On the screen you can see there is a simple case where I have seven different cities. And there are total paths, I have drawn all possible paths on the screen. Every city is directly connected with every other city, so we have lot of paths, how many? Seven minus one factorial, let us see. Seven cities are connected to each other using direct roads. It distinct path is tour covering all cities. For example A, B, C, D, E, F, G is one tour and A, C, B, D, E, F, G is another tour. So there are many other tours possible. The graph is not a directed path. What does that mean? Every road is possible to travel in both directions, okay that is a reverse path is the same path. 

So A, B, C, D, E, F, G is a same tours as G, F, E, D, C, B, A okay the reverse path is the same. Total path between any two cities in a given graph is based on a number of cities that you have. For example, if you have seven the seven minus one factorial, six factorial, okay that is seven twenty. But when we have no directed in this thing it becomes half. So it is become -- so for our case there are total three sixty different tours possible between these seven cities. Three sixty different for us, for a small problem like this only three seven cities there are total three sixty tour is possible. And I want to get the shortest tour. Okay. How do I get one?

There are some ways of doing it and we will see how GA is applied. Okay. Let us see what if I have a case of only twenty five to twenty six cities. In case of twenty six cities, twenty five factorial by two total number of alternatives are possible that comes out to be something that I cannot even read, you can see on the screen, two huge number. And if you try running those program, looking for all possible alternatives, calculating the, the, the length of the path probably the program will not end in your lifetime. Okay.

One of the method is called Nearest Neighbour algorithm which helps in finding out the quite optimal solution for traveling salesman problem. It is very simple, it pickup the any city at random, it pick up the first city at random and that is the city. Then we will pick up the shortest city, the nearest city from that city and so on. We will continue picking up nearest cities and eventually we will get the complete list of cities. So pick up the first city at random and solution city is that uh city then pick up the nearest neighbour of that at that, there is no neighbour exists then return with the solution here, so that means all the cities are explored and so on, okay. So that is called nearest neighbour. 

But then might not give you exact may not be optimal, may not be as-- in some cases may not give you even good answers. Okay. And here one more interesting thing about travelling salesman problem is we can actually choose a Sparse neighbourhood or [indiscernible][0:20:10] neighbourhood function. An excellent example is, let us look at this particular tour A, B, C, D, E, F, G and again A. Why A at the end? Because it – as salesman how to come back to that city. Well the last one, last city is always the first city. We are showing a last city, right now we will not be showing it in other slides. But it is assumed to be there. So here I have this particular tour A, B, C, D, E, F to G to again back to A. 

Now in this particular case this maybe the best tour, this gives me – and how do you decide, in fact for travelling salesman problem the fitness function is pretty simple, the total distance covered negatively is the fitness function. Okay. So we like to increase that, in the other this thing we will like to reduce total amount of distance covered. So for example A, B, C, D, E, F, G, A may not be able to give us a very good answer. So can we go to some other node? I can actually try sparse neighbourhood by just assuming uh, uh a case where two adjacent cities are being exchanged. You can see there are five different cases. B and C is exchange, D and C is exchange, A and D is exchange, F and E is exchange and G and F is exchange. You can see, I bold face them to make sure that you have understand. So I have five different children. Why this sparse, because these – for example I said any two children that is going to be huge, not only the any number of changes, I have a huge value. In fact if I say that, any city exchanged with any other city then I am going to have around three sixty. We know that these many possible, so that many nodes. Okay. So this is a Sparse neighbourhood. Okay, anyway.

Now the most important part, we would like to solve travelling salesman problem using GA. Remember we will have to have set of better solution and combines their parents randomly and combine good elements of parents and so and so forth. And here is an example, we start with a random side of parents say twenty and find their fitness values and choose better five, generate thirty offspring, how you get, because there are fifteen distinct pairs of five offspring that means each generate two children so you get thirty. Okay. And you pick up first five and so on. I have already discussed that thing.

But the, here there is one more word which I will have to use. How you combine two strings? Okay, the method itself is called Crossover. There are multiple ways of doing it. For example, one simple method is to cut string at a typical place. I have two strings. I will cut them at the same place, I pick up this part and paste it here, pick up the first string path and paste it here. Okay. So the first string initial path is pasted with the later path of the second string, second strings initial path is pasted with later path of the first string. Now that is called simple single point crossover. There are many other methods. We will see which crossover methods that we are going to use. Again as I said, I am not going to discuss all crossover methods, we are only going to see a few useful methods which are used in TSP. Okay.

Now there is the first one, okay. For example, let us try to understand, if I take single point crossover is it going to work? That is not going to work. Why? Because if I just say, for example, A, B, C, D; I cut. Now the other string contain something A, D, E, F and now it has some cities which are already occurring here. If I cut and paste them what will happen, I will have two cities, the same city is appearing twice in the route which is not correct and some cities do not even appear, so that is not acceptable. Single point crossover is not possible here. Okay. So let us look at this. Let us look at the first method called Partially mapped crossover. 

Here why it is called partially mapped crossover? Because the partial part is copied and then the mapping of that is used in crossover, let us try to see how it works. For example, I have parent one as A, C, B, D, E, F, G and parent two as C, D, B, G, A, E, F okay and I decide that I use the middle three elements, in the case number one, the parent one B, D, E, parent two is B, G, A okay. And I am going to use them in this crossover method. So the child one remember, it is going to pick up the part from parent two so B, G, A parent two middle part is copied into child one. Similarly, the middle part of parent one is copied into child two. Now the rest is to be picked up from other parent, that means child one will have other cities from parent one and child two will have cities from parent two, okay. 

So now look at the middle part. The child one is B, G, A child two is B, D, E and that is what we mean by mapping. So B mapped to B, B is mapped to G and A is mapped to E, okay just compare them. Okay.

Now how partially mapped crossover works. You can see on the next slide, now it is little, the PowerPoint animation is running, so better try to see how it works. You can see the right hand side we have the mapping. E is mapping to B, E is mapping to G, E is mapping to A. Now the parent one is A, C, B, D, E, F, G okay and now remember the child one, we have already taken the part from parent one two, now the rest is to be picked up from parent one we have already talked about. 

Now how it processes? See the process. Okay. 

Now, the first one is A. Okay. The parent one, first element, first city is A and the mapping says A should be replaced by E. So I will have E here in child one at place number one, okay. Now let us pick up second one, G. Now G is to be mapped to D. So G is replaced by D. Okay. So the child one now has E star which will still have to fill B, G, A star D. The next one D you can see that it is replaced G, D is the mapping. Now C and F, you can see that they are not part of the mapping and that is why they will have to be copied as it is. So once they are copied as it is, you have complete child A.

Now the tour child A begins from E, C, B, E, A, F and D okay. So this is the partially mapped crossover method. Okay. And see as if I said that they are directly copied because there is, they are not part of the map. If you pick up some other strings you probably have different mapping and you will have to do it. In fact, in some cases the mapping is you will have to cycle that mapping in fact if you map the first element is already occurred then you have to again map, so it is sometimes in some cases it is pretty complex but we have taken a very, very simple case here to just make you understand how partially mapped crossover works. I have already told you in the beginning that GA is quite complex so everything that we are talking right now is basically the simplest thing that we can talk about but in true sense it is it may be pretty complex. Okay.

The other one is called Order crossover. The order crossover is very similar to the earlier one but the other thing that we are going to keep the order intact. Okay. How it is done? Again let us see the same thing. The parent one is A, C, B, D, E, F, G out of that we will copy the middle three elements B, D and E in the child. Now you can see that the parent one B, G and A there are B, G and A, they are not to be copied into the child. We know the same parent, same city cannot be revisited, so we are ignoring them, we are cutting them off. Okay. And that, that makes the other elements available to us.

So once they are available to use we are just coping them according to the order in which they appear in parent one. So C is the first, so we copy C here, okay. D is next, so we are copying next D here. Okay. E is next, it is copied. F is also copied, okay, done. So this is how you get the child one. You may get the child two in a similar fashion and we will have the order crossover work. 

The third one is called Cyclic crossover. Cyclic crossover is also quite simple, but here we are taking some other string. We are not taking the earlier string. There is a reason. If we use the same string surprisingly both children comes out to be the same. You may test it, okay. You may try. But that is the reason why I have chosen different side of string. So it is A, B, C, D, E, F, G, H, I little longer and littler different. 

The cyclic crossover is little different so I have chosen a longer to make sure you understand. Okay. So it begins with A. It begins with the first element, okay. I do not have any copy right now I do not have anything to begin with. I start with the first element and put it there. Okay, so in the child. And now what I do? I just find out a mapping okay, element in parent two and find out the position of that element in parent one, so D is at the position of four.

See I started with A, the element correspond to A and parent two is D, the same D appears at position number four in this case, so D at position four is copied, okay, here. Okay. So you first, you begin with A now you D. Now D, so the corresponding element of D in parent two is H. And H appears at position the last but one in parent one, so it is copied there in the child one. You can see now H appears in child one. Corresponding elements, okay you can see. Corresponding element of H is C and C appears at position number three, so that is added okay you can see; a position that appears in child one now. Okay. 

Now see corresponding element is B, so B is copied, you can see that B is copied again, so in child one at this point of time is A, B, C, D, next three are unknown, H and unknown. So we are yet to fill four positions. Now an important thing happens. So B is copied. The corresponding element of B here is A. Now A is already covered. Okay, A is already there so we have a cycle. A, we have started with A, now we reach to A and the cycle appears okay will stop this process and copy the rest of the elements as it is, so A, okay the cycle. Now what I do, I just copy rest as it is and what I get is this, this four, okay. So this is what I get A, B, C, D, G, F, I, H, A so this is what I get. You can see that some part from parent one, some part from parent two. Until you reach to the cycle you copy from parent one, once you reach you copy from parent two. Because we are taking every element from parent one corresponding to parent two the remaining elements of parent two is obviously not appearing in child one, so we can copy it safely. Okay, so…

There are some other representations possible as well. One is called Path Representation which we already have done. Whatever we have done so far is called Path Representation. There is something else called Ordinal Representation. One more is called Adjacency Representation. The Ordinal Representation actually allow single point crossover which was not possible in path representation. Because of that the ordinal representation makes it faster. We are not going to discuss that further. Adjacency, see representation actually helps applying heuristic function little better, but again we are not going to talk about, that is called heuristic crossover which again as I said we are not going to discuss further, that ends our discussion about genetic algorithms and the introduction to travelling salesman problem. 

Let us recap what we have seen in this particular module. 

Genetic Algorithms is a method of solving problems based on how life forms persist. They are not similar to other searching methods. They won’t start from initial state and reach to final state. They actually begins with solution search method. They pick up random solutions in the beginning. Pick up better solutions from that solution set. Then let the solution combined merge together and generate new solutions. Pick up better from that and continue like that. How they are merged is based on a method called crossover. Traveling salesman problem for example, when we talk about, if you want to get the tour which is optimal we may start with a random tour A, B, C, D, E, F, G, H or something here A, B, C, D, E, F are cities. We start with that. We find out the fitness function value. We generate – okay. For example, if you use sparse neighbourhood we just replace to adjacent or exchange to adjacent city information.

What you get are six-seven children and you apply that fitness function, the value, the distance value. And you may pick up two, three or four the state and then again you expand them and so and so forth. So it is possible to use GA this way. When use GA and -- on problems like this it is not easy for you to combine them by using a single point crossover like cutting half here, and cutting the other two and just combine them, because the city is maybe repeated and some cities may be omitted, so that is not is not allowed, that is why we need little different type of crossover methods, there are three crossover methods we have seen, one is called partially mapped where a small part of one parent is copied into children and based on that mapping the rest of the elements are filled up. In the other one, order crossover method we copy some part of the parent into a child and the rest is filled up from the other parent based on the order in which this thing appear in the parent itself.

And the cyclic crossover, what we do is we pick up an element from parent one and pick up a corresponding element in parent two and pick up that element, use that position to store that in the, to copy that thing in the child and so and so forth. And when cycle appears the rest of the elements are picked up from the other parent and copied. These methods are uh, um, either preserving order or position or both in a way that they allow better qualities of the parent to persist the generation. And using this method actually many other problems are also solved. With that we will conclude this genetic algorithm module number eight. Thank you. 

