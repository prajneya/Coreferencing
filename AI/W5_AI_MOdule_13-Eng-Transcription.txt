Welcome back friends! We are into thirteenth module now. We'll be discussing about A star algorithm in this particular Module. A star is a very popular algorithm, is one of the most used algorithms of AI. If you remember the previous module, we discussed about two components of the… the search process. One is already calculated. Remember that, when we were talking about branch and bound, we have seen that when… whenever we are at a typical point we… we calculate the amount of distance that we need to come to this point and then our prediction to reach to the goal node from that point, because the same discussion is extended in A star algorithm. The A star algorithm is based on the simple principle of having two different components. One which is already incurred, the other one is expected to incur. So it… it calculates the cost as the collection of the summation of two different components. If you remember in best [Indiscernible: 1:11] search, we have seen that what we do is we…we pick up the best node. Best node means the node which has best heuristic value.

The A star algorithm improves the [Indiscernible: 1:20] by just adding that the component… The component describes how far we are from the root node. So in other words, A star will not only not find the… the shortest from… path from the current node but from the root node, okay. And we've already traveled to this node. So we don't need to predict anything to calculate the cost of traversal to this node. This is already available as a first component. For the second component we’ll have to actually predict and we'll have to use some heuristic like we have talked about before. As I said AI…A star is very popular algorithm. There are many pathfinding algorithms, pathfinding solutions where A star has found its usage. Many graph traversal algorithms are also using A star shortest route finding in maps and all that also is using.

And there are some prerequisites if you want to apply A star to a problem there are a few prerequisites. First is every solution, there can be multiple solutions to a problem absolutely no issue but every solution is defined by just one node okay. We will soon see that if… what if there are there is a solution which is actually defined by multiple nodes. Here a very simple assumption. There is a single node which defines a solution. There may be more than… more than one solutions where a single node confines towards a solution. Okay. The second requirement is called the admissibility property. The heuristic function that we use if that heuristic we will soon understand what admissibility is, but if that heuristic function is admissible, the A star is guaranteed to give you an optimal solution. If the heuristic function is not admissible, A star cannot guarantee us that. So if you want an optimal solution, for example, you just say that I want the best path, the shortest path from a source to destination, we have to make sure that the heuristic that you use is admissible. The first component, the first component is called g. The first component, remember is the cost of traversal from the start node to the current node. That's called g. The second component from the current node to the goal node estimation is called H dash, okay, and the summation of that g plus h dash is called f dash and… and you always pick up a node with list value of f dash, okay. That's the motto of A star algorithm. Now the slide actually is… is a PPT animation which comes next which talks about how this process happens for a given graph. And the graph is quite huge. It contains a lot of nodes A to Z and one more AA. So it’s a huge graph and the starting node in this particular graph is W and where we would like to reach to a node called B. 

Okay, so that's our job. So we… in the beginning we have no idea how far each node is from the other node. At that point of time we are in the initial state. When we begin, we begin with W okay. When we begin with any node, we’ll need to have two values G and H dash, the G value is from the root node. Now root node is W itself so G value is zero. And now we apply heuristic and the heuristic says that the B is expected to be 15 nodes away or moves away. So when you have that G value is zero, H dash value is 15, the F F dash value G plus H dash is 15. So that is the beginning okay. At this point of time, W is said to be explored…unexplored. And the… the… the unexplored node is one where the G and H dash value is found. Okay the next step is to generate children for W. Once you generate children for W the first child is S and the second child is V. So, more childs are now generated. Once the children are generated, the node is said to be explored.

Okay so… so we have two lists. One list contains all explored nodes, the other list contains unexplored nodes.  At this point of time, W is the only node which is part of explored node and V and S are a part of unexplored nodes. Now, they are unexplored okay. So we… we need to calculate their G and H dash value. G is incremented by one. Now for this particular example, we assume that every R is of length one. So W to S and W to V is of length one. So G value is always incremented by one from the parent node. So in both cases G values is one. In case of S, the H dash value the heuristic estimate of reaching to B is thirteen. In case of V it is fourteen. Obviously, G plus H dash value is fourteen for S and fifteen for V. So obviously S is a better candidate. So X will be explored next, okay. So S and V both of them are part of unexplored list. Now S moves from unexplored to explored and its children are explored now and its childrens are generated now. So S has two children N and H. Now N and H are added to the unexplored node list. S moves to the explored list. Now S is at the G value of H obviously is one plus S, that is two. N also is one plus S that also is two.

The heuristic value from N is nine, from H is ten. That means ten is expected to be ten moves away from B. And the N is nine moves away from B. So that means N is nearer and we…we… we should explore N. So that is done. So now, an interesting thing happens when we explore N okay. One of the children of N is V itself, okay. Now V is already explored. We have already generated it is not explored, but it's already generated it's part of unexplored list we… should we apply G and N… G and H dash? Well not, because these already more than; See please understand. H dash value of that node N is not going to change, is the, is the estimation of how B is far from V. So that is not going to change. But G value in this case is one more. So this path is obviously longer than the previous one. So there's no point exploring this path. So unexplored nodes are just forgotten. They are not processed. Okay. The other children of N is M okay and this N to V path is shown as a dotted line indicating that this is pointing to an unexplored node which we does not want to progress further. 

Now this, remember this is in an interesting thing, because we are always incrementing G by one if a node is regenerated. It is of almost no value to us. But in case if G value is not one but different, probably this newer path may be better. In that case we might need to reconsider. So, this version of A star the first version we are keeping G as one so this is not required. 

In the other case N the other child is M which says that obviously G value of M, now JM is inserted into the unexplored list. The G value is three and H dash value which again it looks, it applies the heuristic and decides it to be eight okay. So once it says that it is three G value plus H, H dash value it is 11 moves away. So, that is picked up. Now the children of M picked up one is H. H is again like the case which is… which was V. So H is connected by a dotted line which indicates that M to H is already unexplored… unexp…generated child. So you don't need to process this further. We can always ignore. So we have two more children okay L and G, out of which G seems better because it… it says that obviously the G value is one more than the N that… that is going to be four but then it is the… H dash value is six and seven for G and H, G and L respectively. So G seems little better. So we explore G now. Again one of the child of G is L which is part of unexplored node so are not going to touch it. The other one… other three F, E and J and looking at obviously their G value is one more than the parent node that is going to be five but then J seems to be nearer okay. So we… the next node that will explore is J. Remember the E F R also added to unexplored list now. 

When we explore J there are two children. One is I other is C. I is explored both of them I and G… I and C both G values are six. But the estimation again is a little different. The… the estimation from I is six while the J is, sorry, five and the C is four. So C is little better. So we explore C next. C has three children. One is E which is already explored so we’ve already generated. So we’ll not touch it. K says it’s five from E five is too little further compared to D which says only two and C says it is four. C is already… E says… E we will not consider okay. In fact there is one more child called Q which we have not… because it is on the other side. You may even calculate that it calculates to be higher value, Okay. But then D when we the next child obviously D is the most promising one So, we'll explore D next and it finds B in the next move. So that… that's how we… we use A star to explore the nodes and find the shortest route from one or to the other. Now the exploration process is shown in the next table. It talks about how the nodes are picked up. You can see that the first row the current note is W which has two children S and V and out of that we’ll choose V… S, sorry. So that comes as a next node and every time the children are added to the explored list if they are not, sorry, unexplored list if they are not already done, if not already added and whenever a node is explored, it is added to the explored list because that node we are not going to look at. If a new node which is already explored we’ll not touch it okay or even unexplored, we’ll not touch it. 

So you can see that how it proceeds and reaches to B okay. The first version of algorithm is depicted next, okay. Initially it begins like this. Initially the root node is expanded G value is set to zero the H dash value is found using a heuristic value. Now, that depends on a problem. We are not discussing any problem right now. So if you… if you pick up a typical problem you can get a typical heuristic and you may use that heuristic for calculating that H dash value. Now the… okay now root node is moved to the explored node and this G plus H dash is applied to all children and you pick up the best child out of it and they are all part of unexplored list. The chosen child will move to explored and the children of that will be added here and if it is already explored it is not generated yet again. Okay. Anytime you will find a node that you're exploring is a goal node… you will… you got the solution and you'll have to quit. Otherwise, find the best node and explore it. It's thus the same process. Find out H dash using heuristic, you already had the G value, add them calculate the promise the node is giving you and choose the best node, okay. But then there is one cases I've already talked about. We have already used the G as one in the previous example and said that G can… G may not be one every time. So what if G value is different than one? There are three Rs going from a node and that is something which is very common in real world. For example, there is a place called A and there are three paths one connects A to B the other one connects A to C the third one connects A to D. In that case it is quite possible that A to B is far far longer than A to C and A to D and so on so forth. 

So not every path is… is the same and if you accept that, the G…G value may remain the same, but the H dash values are unlikely to change. When the H dash values are likely to change, the calculation differs a bit and how it is done. We'll take another example using another PPT with another PowerPoint animation, okay. So that is now we are taking the value actual value of H dash. 

Now we again start with W, the same zero and fifteen. Okay you may there’s one… one thing which I… I… I should tell you right now. See this fifteen is our estimate and we actually get the solution much earlier, out of seven or eight iterations we get in fact, I  think believe I believe eight iterations in the last case we got… we reached to the destination. Now we estimated it to be 15 and we reached there in eight. This is called overestimation, we overestimate our that thing exactly the opposite case  is like A the W says it’s four hops away and it actually finds 8 hops away. So it is called underestimating. Now, which is better? In fact, best is to get the right estimate, okay. If you get eight here it is the best thing, but that is never possible in most of the real-world cases. So that is out of question. One important thing about overestimating is that it does not guarantee us. If there is the heuristic function is overestimating, it doesn't guarantee us the optimal solution. But the underestimation yes, we are guaranteed to get an optimal solution. Why we'll see little later but point is this is overestimation. For this example I have used overestimation. But remember that however good this thing is, it does not guarantee us the optimal solution. If you want to get an optimal solution there has to be consistent underestimation. Anyway so let us start again with W we have zero and fifteen like we had before. We have both children like before, but now you can see that the G value to… to V is five okay. It is further very long route and the H dash value is ten. Similarly S like previous case one and ten. Obviously S is a better child so we move further I won't discuss much about how they are explored and generated exactly like the previous case. Okay, so we have H and N and out of that N is little better okay is nine plus two that is eleven so that is short minimum. Okay now interesting twist in the tale comes now. N has two children M and V. In the earlier case, we have just ignored V because it's likely to have more value of G. Now you can see that the value of G is three if you traverse through N. What does that mean? If you traverse you from W to V directly is a longer route. But if you traverse that through S and N is a shorter route which is which the length of which is only three and at this point of time you can see that it is the shortest path okay. So, this is a difference between earlier case and the newer case okay. The earlier case we have assumed all arcs with the same length. Here it is not so, and that's the reason why the alternate route to V is found to be a better. Seemingly longer route is actually shorter, okay. So, that is probably you have seen something similar in real world as well. So, the point is, this is different. So after N in the earlier case, we have picked N is the next best child, but in this case we’ll pick up V. See you can see that there are two paths available from W to V one a direct path and the other one which traverse through S and N and the direct path is longer and the path through N is shorter okay. So we'll pick up that path and now you can see that V is a better child. So now we'll explore V next. So when we explore V next it has only one child called Z. Now we explore Z because that’s the only one option we explore it and we had four plus seven total eleven. 

It is not improving. It's the same but we still accept it. We will go ahead with the next. There are two children of Z Y and A. Y obviously is more expensive than A so we'll choose A then X, X has two children O and U. So O seems cheaper because seven plus three that is ten. So it… it sounds little cheaper compared to U which is thirteen in total. So we explore O next. Again there is one more twist in the tale is coming next. So there is a path from O to K which is nine and five. Okay, so that sounds better. So we'll… we'll pick up that, okay. So and it has two children one is I other one is A. The path to I sounds better but then you will find that it is not as good as the earlier path okay. The best path the both child of K are much expensive than the previous child okay. So O to  I link which we have not explored before. O to I link which was eight five which was not all that good when you compare that with OK link is found to be good, is found to be better. So, what we do is from K we backtrack to O. Now this is something which is going to happen only here. This is not going to… this… this case was not possible in the previous case. You explore children. Now, the G value the value becomes so large that you will find that this path is no longer optimal. The better path in fact, from O there were two paths one is I the K, the other one through K and K you start traversing through K you realize it is more expensive than OI path you come back and start from OI. So that is one thing which is happening here where you explore I, you will find obviously K is one of the children that is explored J and D are the other two children out of which obviously D better. So we explore it and then it comes to B which is the destination node. Now you can see that when we change that assumption, G value we take g value as real, you can see that the path changes. Now in real world this is also true because G is what the cost of reaching to a node.

Now that cost again depends on perception. For example, pick up a city map. Now, if you're traveling using a car, the traffic jam or the time to reach to destination is going to be different if you compare it with the two wheeler. So a congested but less… the route with lesser distance probably is preferred on a two wheeler by less congested but longer route is preferred by a car because your G value is different. In case number one G value is the distance when in the other case G value is the… the minus time that you require to reach to that destination okay. So, if you change that G estimate, the way you look at G at the path changes. If you pick up only every junction as just one distance from it you will get a different route, but if you take the actual G value, the question, the answer is very different.

 The next slide talks about how that is being processed. The only important part is highlighted bold faced in… in this particular table, you can see that the… the I children are P and D. Now that is coming after… so see look at two rows up O had two children K and I out of which we chose K. And when we chose K after that we realized that it is a longer path we backtracked and started with I. Now that is the only thing which is different in this particular case than the earlier case and that's why it is highlighted. Okay now the second version of A star. They… nothing different here it just initiate the process by adding a root node and then root obviously has G value as zero and H dash value as whatever it is. Then G value is again calculated when you explore the nodes the child you calculate that case. In case of a city map probably you will calculate the amount of traffic or… or the distance or the time you take to…reach to that whatever. So that is G value you calculate the value find out what's the cost of reaching to the next node that child pick up the best child okay, keep them in the list. 

So pick up the best node unexplored node okay, like we did before. The only catch comes where you have to backtrack. So, there is a path variable, which is always adding the new node. When there is need to backtrack, that part is to be extracted. That part is to be removed and then you again start from the optimal path. So that is a different part that is little complicated thing, but that's what you're supposed to do. Okay why this backtracking is necessary? Sometimes now there's… there’s something okay what… what if the values are changed. In the previous case if you… if you remember those key estimate was less, but when it explores the children calculates the G value it realizes that it is longer than it was expecting. So, whatever your expectations H dash value whatever you assumed, once you explore your children it is likely to change. 

So, in this case that was propagated back. So, the previous node O node found that O to K path which it thought was shorter is actually a little longer. Then it chosen it has chosen that OI path okay. So that unless you propagate that back probably you will not be able to get the optimal path. So that back propagation here is also very, very important. 

Why that is necessary is shown in the next slide. Okay, let us, now this is a little different kind of a graph. But again, our starting or the root node is assumed to be W. But assume that now it is connected by some other node. So, we…we assume that the G value is N and S is N plus one five… twelve or five, fifteen something okay. So something is being calculated okay. So, in the beginning W was N and fifteen. Now, when you explore X and V we realize that instead of fifteen, S says that it is only twelve hops away and V says  that it is fifteen hops away. But the G value is five G value is more, just assume that it is N plus one N is assume N to be four then S is better. But then it is only twelve plus one thirteen. Now W earlier it was thinking that the goal node is fifteen hops away. But after exploring two children, it can say that if it goes via S it's going to be thirteen. So it is shorter. So if it… should it improve that? If it doesn't what will happen see AB also there is… there is a point there is node which is called AB, which also makes a decision it… it has two children W and AC and out of which it choses W and in this case when the estimate is getting better, the best path still remains the same. So, we don't need to worry about. But it is quite possible that there is also a decision being made at the earlier point. Okay. 

If assume that the S value instead of twelve is seventeen and V value instead of fifteen is fifty is twenty. So the W value instead of fifteen changes to a higher value in case of… if it chooses S it is going to be twenty. It is going to be larger. If it is not propagated back, AB will not be in a position to decide that AB W is no longer an optimal path. AB AC is better okay. So, this is very important even if there is improvement, you may not propagate it back but if there is no improvement you should do it. Okay but then even in the case of improvement like in this case where W the estimate from W changes to thirteen. If it doesn't propagate back what will happen is if there is some change in that graph later which says that AC is N fourteen. Incorrectly AB would prefer AC if that right estimate is not sent back. Okay so to prevent that even the correct estimates are to be propagated back and they are to be propagated back to whatever root node is okay.So all paths are to be updated. Now this is a critical part about A star. 

Okay with that note, we come to an end of this particular module. In this particular module, we have looked at an important algorithm called A star, we have seen two versions of A star in this particular module and in fact the third version requires that back propagation which we have not seen, but we have seen an example of… It is about two things. One is the estimate from the current node to the goal node and the cost incurred to reach to this current node and always we’ll pick up a node which has best G plus H dash value. G is the cost and H dash is the estimate. And why H dash and not H? G is G H is not H but H dash. Why H dash? Because the designer us trying to convey that H is the correct distance and H dash is an estimate. So dash is indicate… indicator for that assumption or… or prediction. Okay so H dash is a prediction of the H value. So and will pick up the best route okay based on G plus H dash value. With that we’ll conclude. Thank you. 


