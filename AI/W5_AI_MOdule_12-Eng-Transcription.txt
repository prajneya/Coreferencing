Welcome back friends to the twelfth module of AI in which we are going to talk about a few more search algorithms. One is ant colony optimization, the other one is called branch and bound and the third one that we are going to look at is called refinement search. Ant colony optimization is a very popular algorithm some time back is still being used, but not to the extent used to be. But is an interesting idea and probably a lot of others have used that idea and we are going to stress that idea. The idea is about using a very small tiny agent with very little information, lit… little processing power but able to do things which are unable to do by many other things, very, very simple solutions which are parallel. How that is done is the essence of this ant colony optimization. If you've seen how ants find their food source, okay, how they move around and find that food source, if you have studied that process, you probably understand what I'm talking about. A lot of researchers were interested in learning about this and they have found very, very simple method that they are using for doing this which is basically implemented in computer program and it can actually used to solve many search algorithms. Many, many, many search problems which otherwise are not possible to be solved and that's why it's become a very, very popular algorithm as I said. 

How the ants find the food source and then retain that? So what does ant do? When it starts traveling on, when it is searching for a food source it sprays the pheromone along the path. Then pheromone it’s tendency to evaporate. Suppose it finds the food source it follow the same path to come back. So, it reiterates re strengthens the pheromone volume. Now whenever the other ants start moving, what does it do, it looks at all possible paths and there is a high probability that it chooses a path with a higher value of pheromone. So, if an ant has found a food source, if other ant is looking for a path there is high probability that the other end chooses the same path. What is the consequence of it? The other ant also starts spraying the pheromone along the same path and it'll add to the… the amount of pheromone and what does that mean? That means that the path becomes more attractive for other ants, okay. So, and what if some other ant has travelled some other path? If the ant has traveled some other path without having a food source will not going to come back the pheromone value will evaporate. So it won’t remain as attractive as possible as it should be after a while. 

So, this simple method of spraying pheromone value and let it evaporate over time actually decides a path which is, one, recent because the pheromone value if it is old will evaporate and second most preferred by others because most… more ants travel along… along the path more pheromone value. So, the point is, this ant colony optimization method is based on this two simple parameters whether the path is recent or whether its path is traveled by multiple agents. We’ll also look at two other methods of search called branch and bound and refinement search in this particular module. Basically ant colony optimization is about learning what others are doing and learning to solve problems like them. Okay, not only that, one. Second point is that you share what you have learned ants they’re spraying pheromone values. Those pheromone values are indicators for others. So, they share this information. For example, if an ant is traveling and it has two different paths and one with higher pheromone value other with less pheromone value it’ll understand that more ants have traveled along this path and this path is more recent will probably pick up that path, okay. 

So, that is what it is doing and researchers are looking at nature for inspiration and there are many examples like ant colony optimization, and what they learned how ants shortest path to their food source, they devise algorithm capable of working with small components like ants, they call agents, and which is very, very low intelligence… intelligence level agent with less memory, less power. And the components are very simple design, obviously, because it doesn't do much - spraying pheromone calculating value of pheromone and deciding these are the only three things the ants are doing, and they can share the information and this is the simplest way of sharing this information. They make decision based on that local information which they have and each component each ant is going to decide its path on its own and many ants work together, okay, for food source and when some of them find the food source, others will tend to follow this path and after some time they converge on that path. You probably have seen that thing yourself and we’re going to write we’re going to discuss about the algorithm which does the same thing.

Their work… they are working in a coordinated way and the pheromone value is an indicator, the tool which they use for coordination here, okay. The same thing is used by, similar thing is used by the programs okay. The primary job… the… the job of an ant is to find the food source nothing else. That's… that's their primary source that’s primary job to do. Quite interestingly, they also find shortest path how let… let me talk about how they find the shortest path. Suppose if there are two ants one travels here, the other travel through a longer path and both of them have found the same food source they travel along their own generated path but then there are two outgoing lines for the third ant. There are two outgoing possible paths. Now the longer path for example, in ten seconds this ant make five trips, this ant make four trips. Obviously, because it's a longer path. The amount of pheromone obviously is more on this. Not only that, because it is more recent also because it's traveling faster it is more recent number of pheromone also is more. That means this path is more attractive. It's very likely that the third ant will follow this path when the third ant follow this path will also add to that pheromone value. That means even if the fourth ant will come is more likely that it’ll will pick up that path and more and more ants preferring that path almost every ant will follow that path. Okay. So, it's basically an algorithm. That’s why the word optimization appears in this case and also it’s very interesting that the ants can also rediscover the short path… the shortest path, how they do it? And there are a few prerequisites. Let us first of all, talk about those prerequisites how they use a pheromone here. They start traveling in random directions. In the beginning they travel at the constant speed and they spray pheromone along the path. 

The pheromone evaporates at constant speed and the ants are capable to smell the pheromone value and so on so forth and tends to follow the path with the strongest pheromone value and… and I've already told you that it depends on two things - more ants traveling on that path where number of… the amount of pheromone is more and the path is more recent the value is more. Then they are they are successful in finding it. It’s more likely they travel back on the same path and it attracts more number of ants, okay. And unless it cannot find a food source it is not going to come back. So that path will no longer, not look attractive which the ant has not found the food source. So it… it directs the behavior in successful directions and inhibits unsuccessful directions. 

Okay you know that it is quite true for us as well. If you have lost your path, you will prefer to walk on a trail, okay. Because you know that this trail… the for example, you lost yourself in a jungle, you’ll travel on a trail which is which is there, you know that this people have walked on this and that's where there is a trail. So it's more likely to reach to a solution. So that's precisely what is happening here. And I've already told you that it is shorter paths are preferred and there is a PPT which talks about that and what… I've already told you the other thing, that if there is some change in the path, the optimal path changes. For example, there is an obstacle which is placed. You can see that the PPT talks about the obstacle that the ants are finding. Now when the ants will continue traveling it will travel A, B and C and now traveling towards… now when they reach to that obstacle, they have two options. They take the lower part of the obstacle, the upper part of the obstacle. They travel along that and again, they start traveling in a random fashion but usually along the obstacle. The same way there are ants coming back from E okay because F is a food source. So the ants which carry that food are coming back on the same trail. So when they are coming back from E again, they find the obstacle. So, again they choose from either upper part or the lower part of the… and we assume that it is… it is done with equal probability. What will happen is there are two paths available now. There's path one and path two. 

Now you can clearly see that path one is little shorter. When path one is little shorter the ant from E will reach faster over that line and more ants will be traveling on that line number of trips that probably… because we assume that equal number of ants coming from both directions. You can see that the path one you will have more number of ants traveling and more frequently. Obviously, the pheromone value on path one will be higher. More number of ants coming from either C or E will prefer that path one and that will make it more attractive. After some time no ants will be traveling along path two. All of them will start using path one and you can see that when they find path one again it is the optimized path. So, the… the biggest advantage of using ant colony optimization is that it is possible to re discover the shortest path if there is a problem. There is some dynamic issue in the path. Okay. And that's the second great thing about the ACO. It invariably finds the shortest path. That's the first thing it generates optimal paths again when there is an obstacle placed and there are three good things about it… It uses a simple agent. The ant is very simple agent with very few functions and which has… which has very limited intelligence. But the… the biggest advantage is that it uses collective intelligence okay. People use a lot of other names for this and one very good domain which is called crowdsourcing is also doing something quite similar what… and we have already seen they leave pheromone trails and decide and all that and there are a lot of variations to this basic algorithm exist. We are not going to discuss about them. But there are multiple ways you can use this algorithm and there is some similarity between a ACO and the other things that we have seen. We have already looked at genetic algorithms. There is some similarity in GA. We know that the solutions are broken apart and reconnected and find best solutions. Here also build solutions now you know, there are multiple solutions and you prefer a better solution. You leave solutions which are not optimal, you choose solutions which are optimal. So something quite similar to GA is happening.

The idea of using simple systems and combining them, the power is quite unique. It's not found in other problem… other problem-solving methods that we have seen. Now you can even compare that with neural networks that you have seen in the previous module. But obviously, this is different. Neural network, also we use small neurons, which can work together to solve complex problems. Here also we use smaller agents which are used collectively to solve complex problems. There is some similarity with simulated annealing as well. You have multiple neighbors, multiple solutions possible. The algorithm chooses one out of those cases.

In simulated annealing, you're allowed to choose a little less optimal path sometimes. In case here as well ACO as I said it is will… ant will not always use the path with highest pheromone value but the probability is higher okay. So that that sometimes it chooses a non-optimal path as well and that helped it come out of that local minima or maxima issue like the simulated annealing okay. The same thing is happening here. Now, let us look at the Traveling Salesman Problem. How you can solve a traveling salesman problem using the ant colony optimization? How it is done? Now, in traveling salesman problem you have cities they are connected and those connections we… we call them segments. So each segment is initialized with pheromone value of zero in the beginning okay. So the beginning no path contains no pheromone value. Now what you have to do is to start from one node and send agents to all paths, okay. So, multiple ants are traveling on all possible paths laying their pheromone along the path and in fact in case of a program it doesn't start laying pheromone immediately. Does something else. In phase number one let them reach to the final this thing the city and calculate the distance the length. How it is done? Once this is done, then the actual processing of algorithm starts from now on because now we have some value of pheromone set for all segments. Now the ants will again start traveling from the very node. Now there are some pheromone values available. So what you do is you just pick up the first segment and this how the pheromone values are? Okay, let me even talk about the pheromone value is the length is inversely proportional to length. So pheromone value is some constant value divided by the length. So the longer the path, less the pheromone value. Okay so those paths are already found so that pheromone value will… of a segment, okay, is equal to total number of ants traveled multiplied by the pheromone value that they have sprayed on that…

 So that pheromone value is based on the distance also. So longer paths lesser the pheromone. Now suppose you have five outgoing possible lines. So out of that you choose the best okay maximum pheromone value and go ahead and go ahead means you pick up the next segment… segment and the next segment okay. So, you can see there are four steps shown on the slide which… which does just that okay, and just go back. You just lay pheromone again once you reach to the last segment, lay pheromone value again and then again start the process. When it is over each segment is revisited, the pheromone values are updated, again the process starts. So it will happen a few times. You will find that almost all agents start following one path and that path is obviously the shortest path, the same way like we have seen. 

Okay so you use multiple agents but eventually it’ll converge to a single path which is the best path. Now this is only about one source, one destination and you will have to do this for all destinations and from those destinations to all other nodes. Now that is to be… so this process is to be continuously repeated for all such paths. But you may do this and you will be able to get the right answer. For all source and destination you will be able to get this. So this way, eventually you will be able to get an optimal path from any node to any node and this is precisely what we want. Out of all possible cases you get… converge to the best path and once you start getting such paths obviously, you will be able to get the right tour okay. This is called tour. So once you get the right tour, the job is done. In fact, TSP what you want to get is the same node back. So you can even take that case - the first node second node third node fourth node the last node then the node itself. So you can modify that. Once you do that, all possible tours are provided to agents and they travel on all tours and they do change and all that eventually they’ll converge to the best path and mathematically representing this part is also possible. So, what you could do is, you can say that the pheromone value for the next segment, next period is equal to older pheromone value multiplied by one minus row. Row is the constant rate by which it is decremented. So some value is decremented okay, over… over the period of time plus whatever is added by newly… new ants which travels down that path. So there are two components which are used. Here it is shown as tau T plus one tau is the value of pheromone equal to T… T… tau T the earlier one multiplied by one minus rho okay. So that is the earlier case plus the decrement. Then you add total collective pheromone added by the ants in the current cycle so, that is delta tau T plus one. So the two components are added. Now, what is delta tau T plus one? It is basically summation of all ants and their pheromones. So, that is also talked about later in the slide that delta… delta T plus one tau T plus one is basically I equal to one to N delta tau T plus one I, which is a contribution from Ith ant.

So total is basically collected from all ants traveled on that path and those ants which have not traveled on that path they’ll not contribute, okay. So, this one zero to n only includes the ants which traveled along that path and no other ants. And again, what is the I value?… What… what is… what is the pheromone value that an ant add? Remember ant adds a pheromone value equal to the constant value C divided by the path length. So longer the path less the pheromone value. ACO is applied at many places including solving a vehicle routing problem, assignment problem, set problems, image processing where you need to process in highly parallel fashion. And the algorithm is quite dynamically and an adaptive algorithm which can learn on its own and can change over to an optimal path when there is a change in the problem statement itself. 


There is the other algorithm which also is quite useful. And it's not an algorithm. Sometimes people call it only a refinement. Sometimes people call only in addition to any algorithm. In fact, branch and bound is possible to be used with other algorithms as well. So that's the next thing that we are going to talk about is a method to optimize. Now what is branch and bounds? Technically, it is pretty simple. For example, I've started from A and I want to reach to Z. So I travel along one path and I get the distance from A to Z using that path is say thirty-five. Now we start along some other path. I wanted to find the shortest path. So I'll start exploring the other route. And I've traveled A to B, B to C, C to D, and at that point of time, it goes beyond 35, it becomes 40. What's the point in traveling along? This path is obviously longer than one that I’ve already found. So, I don't need to go further. I just skip that and I'm not skipping one path, I'm skipping many paths, because after D there may be nine branches. So I'm skipping and I'm pruning all those branches, okay. So, this is called branch and bound, this is some simple method. So, and if I get one as thirty-four the other one is twenty-two my lower amount reduces to twenty-two. Now I will trim anything which is less than twenty-two because I already have a solution which can provide me twenty-two. If anything less than that, what’s the point? I want that less than twenty-two if something is more than that the path is of no interest to me. 

So that's… that's the idea of branch and bound which is pretty simple. But how do you search using branch and bound? Okay the algorithm is pretty simple. You just pick up next city from the list of cities. If no city left return back, but otherwise return back with the length and if… and then check the length. If the length is more, just terminate. Okay, go back to next city okay. Normally what you do is you just start from all city and pick up first path then the second path then the third path then the fourth path. Here you do  one more thing you just travel first path record minimum, consider that as a minimum path, travel next path if it is more than minimum just terminate it from there and skip branches and so on, okay and this branch and bound is great, if you have chosen somehow has some heuristic which can help you choose shorter paths before you'll be able to gain a lot out of this, okay. And the algorithm is shown here. Pick up the next node and refine solution with that node, calculate the total distance to be covered. So, everything that I talked about is… is shown here. You may worry or you may query that, what's the difference between branch and bound and nearest neighbor. Remember nearest neighbor also was a very good algorithm. But the nearest neighbor does not give you any guarantee for optimal solution. It’ll give you a good solution, but not optimal solution. Branch and bound on the other hand will give you yes, optimal solution. 

Nearest neighbor was only four TSP. Branch and bound is for other problems as well. In fact, bound… branch and bond can be combined with any search algorithm, even we have taken the case of finding the shortest route between two cities. In fact nearest neighbor is quite interesting. You can use that thing as an algorithm or heuristic. I was talking about if you… if you use some heuristic to find the shorter paths before. So if you use nearest neighbor algorithm to find one path and then travel other paths and see if it… if they are going beyond that nearest neighbors skip them. So that heuristic can help you finding better paths before and [Indiscernible: 22:03] branches of search tree and obviously you will be able to gain a lot in terms of the search time. One example is also shown in the handout as well as the PPT. You can see that you start traveling from A to B then C then D okay and you will find that this path which you want to go from A to E this particular tour or path, the length of that is two twenty-five. And if you start taking the other path A to B and D, it's already crossing two fifty and you won’t…won’t go further. There are many paths D to E, D to F then G and E and so on there are many paths which we are not going to look at those paths. So many paths are avoided using this branch and bound.  Remember we have discussed about solution space in the earlier modules. That solution space is now you know, we… we can start traveling in search space using two methods. One, you pick up the first state, second state, third state start applying rules and go ahead. The other method you just get all solutions, okay and pick up the best solution, refine that solution, okay, pick up the solution. You start with the solution, and then continue refining the solution. When you do that in case of refined this thing the branch and bound that thing is known as the refinement search. That process also is very simple, very logical. And we… we let us take the case of seven cities and we pick up a city as a root node and you just start traveling like you do. But then here are… exam…you already have the paths ready. The solution space ready, and you initialize the solution using a very simple thing. You just assume the path between these two okay, the length between this now how do you assume? How do you find out? Now very simple heuristic can be used here. Suppose if I… I just pick up all cities, finding out distances between them. If you look at the next figure TSP with refinement search titled image, you can see that you will get distance between every node to every other node and that is also depicted as a table, as a distance matrix, okay. So from every node, every city you have a distance to every other city now, if you want to find out the cost to reach to that city, you can assume that that cost in the final tour, that city is connected to two nearest neighbors okay. For example a case of D, okay. D is connected to all of them and there are two of them will contain only one fifty. B is one fifty and C is one fifty. They are nearest neighbors of D. So what you do is you use C, they are being used okay. So somehow BDC is used. So to reach to D this is the minimum bound okay. So we use that thing as a heuristic. So in the beginning we’ll use just this and calculate. Now we go further and cal… find out the actual distance. The actual distance is obviously more than what we are assuming here. In fact when we… we explore the tree we… explore the tree for a case, the next case, the partial solution tree. We start from A then explore and okay what are the trees, what are the cities possible to be reached? Everybody every other city than A from B every other city then A and B and so on so forth. So for everyone you are actually calculating. You are finding out the path and I have… this is a partial solution tree. I have reached to D. Now I want actually to find out path from A to again back to A considering all seven cities but the rest is not known to me. But the rest as I have said you can use that heuristic to find out the path which is there.  Now if you remember our best space search and all that we…we use something similar. We use two components, one which is an actual distance. In case of a A to B it is two twenty and A to D is two twenty-plus two fifty plus one fifty. But beyond D you just use the heuristic to estimate the remaining path. 

So, one is the actual distance, the other is estimated distance and based on that you will figure, you will find out which path is more promising, and we'll explore that path first. Remember, if you explore more promising paths first, it is better for us because we'll be able to eliminate the paths which are non-optimal, okay. So, this is basically the process. Remember the tour cost for example, in this case, one ABCD is so far two twenty plus two fifty plus one fifty that is six twenty. And we want to an estimate A, B, C, D, E, F, G. Now E, F, G, you just calculate that using the simple heuristic that I talked about, that table and find out. Now you may ask me for… in this case, why you want to estimate E, F, G. You just calculate like you have done here. Yes, we can do it because we only have seven cities here, we'll… we'll be able to do it very easily. But if you have two thousand cities or five thousand cities or even one hundred cities, it is going to be impossible because the number of permutations and combinations are too much for you to actually do it. 

So, we can’t do it and in that case this heuristic is going to be quite useful. So, there are two components involved. One which talks about the tour cost which is already incurred. The… the amount of… we have already traveled okay so that we have value which is known and that… that is not an estimate of anything. The rest is an estimate, okay. So, there are two components and we can pick up the shortest tour based on multi… addition of this two components, okay. And we'll find out [Indiscernible: 27:25] for all possible paths, we just add components, we’ll find minimum and then start traveling. So we can get a tour with lowest value. So this is the solutions search. 

The question that one may ask is this - Branch and bound is great the [Indiscernible: 27:38] search we replace by branch and bound in all cases? No, sometimes it is not. Remember branch and bound prefers the nearer, this thing, the nodes. Sometimes it is possible that a static node is here, the ending node is quite far and the surrounding nodes there are plenty of surrounding nodes in a near that thing. So, if you use a [Indiscernible: 27:57] search you are likely to get the solution much faster. If you use branch and bound we’ll try traveling in this direction continuously for a quite large period and that's why it takes it will take more time in converging. 

So, in branch and bound however good it is, it does not have any sense of direction in true sense. And remember a true sense of direction can only come if you have a good heuristic okay, otherwise you won't have so that's the point here that I will like to make. With that we’ll come to an end of this particular module. In this particular module, we have seen branch and bound, we have looked at in…In fact, we began with ant colony optimization and we looked at how ant find the food source and then how one can mimic a computer program to do the same. And then we have seen the branch and bound search which looks at the… the minimum value that we have found so far and keep a track of the new search path. If search path is going beyond that minimum value, it terminates that itself there and refinement search which acts over a solution space and does exactly the same as branch and bound. With that note, we'll end this module. Thank you.
